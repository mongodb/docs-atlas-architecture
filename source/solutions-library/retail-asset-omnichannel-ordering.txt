.. _arch-center-is-omnichannel-ordering:

===============================================
Building Modern Omnichannel Ordering on MongoDB
===============================================

.. facet::
   :name: genre
   :values: tutorial

.. meta:: 
   :keywords: Catalog, Omnichannel, Retail, Real-time analytics 
   :description: Learn how to build an omnichannel order management system using MongoDB Atlas, Change Streams, and Triggers.

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 1
   :class: singlecol

Build fast, reliable omnichannel ordering by leveraging real-time
updates using Atlas Change Streams and TriggersAtlas. Leverage. 

**Use cases:** `Catalog
<https://www.mongodb.com/solutions/use-cases/catalog>`__,
`Omnichannel Ordering
<https://www.mongodb.com/blog/post/improving-omnichannel-ordering-bopis-delivery-with-mongodb>`__

**Industries:** `Retail
<https://www.mongodb.com/industries/retail>`__,
`Manufacturing <https://www.mongodb.com/industries/manufacturing>`__

**Products:** `MongoDB Atlas
<https://www.mongodb.com/products/platform/atlas-database>`__, `Change
Streams <https://www.mongodb.com/docs/manual/changeStreams/>`__,
`MongoDB Atlas Triggers
<https://www.mongodb.com/docs/atlas/app-services/triggers/>`__

Solution Overview
-----------------

While customers today expect seamless shopping experiences that
effortlessly blend online and offline channels, retailers struggle to
implement modern omnichannel solutions to meet customers where they shop
with a consistent experience across all touchpoints.

While offering convenient options like “Buy Online, Pick Up In Store”
(BOPIS) and “Buy Online, Get Delivery at Home” is essential for
remaining competitive, implementing an omnichannel strategy presents
significant technical challenges. Retailers need a flexible system that
can provide real-time visibility, handle dynamic traffic patterns, and
enable modern integrations across all customer touchpoints.

This solution demonstrates how to build an omnichannel e-commerce
website using MongoDB Atlas. The demo showcases a customer journey where
users can choose their preferred shipping method (BOPIS or home
delivery) and track their order progress in real time until delivery. By
leveraging key MongoDB features including `Change Streams
<https://www.mongodb.com/docs/manual/changeStreams/>`__, `Atlas Triggers
<https://www.mongodb.com/docs/atlas/atlas-ui/triggers/#std-label-atlas-triggers>`__,
and the flexible `document model
<https://www.mongodb.com/docs/manual/core/document/>`__, you'll learn
how to create a robust, scalable omnichannel ordering system.

.. video:: https://www.youtube.com/watch?v=iFdrlttUozk
   
Reference Architectures
-----------------------

At its core, this solution leverages MongoDB's `Change Streams
<https://www.mongodb.com/docs/manual/changeStreams/>`__ and `Atlas
Triggers
<https://www.mongodb.com/docs/atlas/atlas-ui/triggers/#std-label-atlas-triggers>`__
to enable real-time data operations across multiple applications. The
architecture consists of two main components: Real-Time Apps and MongoDB
Atlas.

The Real-Time Apps side includes any application that responds to the
database changes, such as e-commerce, distribution center, warehouse,
and inventory apps.

Within MongoDB Atlas, the workflow is as follows:

1. An action produces a data modification (like an order status update).

#. The event is registered in the Orders collection.

#. These changes are recorded in the Operations Log (oplog.rs).

#. The Change Streams API monitors these changes.

#. Based on your architecture needs, you can choose to:

   - Perform the update on the application side.

   - Trigger an automated task through Atlas Functions. 

Beyond our current implementation, this architecture provides a
foundation for various real-time scenarios, such as:

- **Real-time notifications:** Automatic customer alerts for order
  pickup readiness.

- **Reactive systems:** Smart inventory management with automatic
  restocking.

- **Event-driven architecture:** Real-time microservices synchronization
  with optional Kafka integration.

- **8Change data capture:** Immediate system-wide product price updates.

- **Real-time analytics:** Instant fraud risk recalculation using ML
  models.

.. figure:: /includes/images/industry-solutions/omnichannel-architecture.svg
   :figwidth: 1200px
   :alt: Inventory management workflow with Triggers and Change Streams.

   Figure 1. Database modifications are logged in the oplog as events.
   The Change Streams API monitors changes, detects watched events, and
   triggers real-time responses in applications or Atlas Triggers.

The simplicity of this process comes from MongoDB’s `replication
<https://www.mongodb.com/resources/products/capabilities/replication>`__
feature and the underlying operations log (`oplog
<https://www.mongodb.com/docs/manual/core/replica-set-oplog/>`__), which
records all database changes. This mechanism allows Change Streams to
efficiently push updates to your application without adding extra layers
or complexity. Replication primarily ensures `high availability
<https://www.mongodb.com/resources/basics/high-availability>`__ by
maintaining multiple copies of data across nodes and enables real-time
updates. Applications can monitor changes at different scopes
(collection, database, or cluster-wide) and filter specific changes
using the `Aggregation Framework
<https://www.mongodb.com/docs/manual/aggregation/>`__.

Data Model Approach
-------------------

The primary collections — products, transactions, users and locations —
form the foundation of our inventory management system. These
collections represent your stock, incoming and outgoing movements that
affect stock levels, your app users, and the different locations that
the inventory system is serving.

What sets the document data model apart from traditional tabular models
is its remarkable flexibility, making it the perfect choice for
achieving a single view of inventory. With a tabular approach, achieving
a comprehensive overview of your inventory would typically involve
complex joins across multiple tables. However, with MongoDB's document
model, this complexity is eliminated. 

For instance, in the transactions collection we take advantage of the
`Extended Reference pattern
<https://www.mongodb.com/blog/post/building-with-patterns-the-extended-reference-pattern>`__
when referencing an item. We not only include the *product.id*, but also
the *product.name* to be displayed in the UI without the need of a join or
an extra query to the products collection.

If we now consider the products collection, we see how it encompasses
what would have otherwise demanded over 10 tables in a relational
system. For example, the product variants are contained as an embedded
array in the same document, and other attributes such as product stock
or locations would traditionally require additional tables. This
transformational power stems from the document model's inherent
flexibility. It not only empowers a more intuitive design but also
ensures that related data is stored together, optimizing access.

Equivalent Relational Model for Products
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. figure:: /includes/images/industry-solutions/event-driven-data-model.svg
   :figwidth: 1200px
   :alt: Equivalent relational model for product.

   Figure 4. Product collection equivalent in a tabular setup

Document Model
~~~~~~~~~~~~~~

.. figure:: /includes/images/industry-solutions/event-driven-document-model.svg
   :figwidth: 1200px
   :alt: Database model with MongoDB.

   Figure 5. Take note of how complex objects and arrays are embedded
   directly within the document

.. code-block:: javascript
   :copyable: true

   {  
      "type": "inbound",  
      "location": {  
         "origin": {  
            "type": "warehouse"  
         },  
         "destination": {  
            "type": "factory",  
            "id": {  
               "$oid": "65c63cb61526ffd3415fadbd"  
            },  
            "name": "Bogatell Factory"  
         }  
      },  
      "placement_timestamp": {  
         "$date": "2024-04-08T15:13:58.822Z"  
      },  
      "items": [  
         {  
            "sku": "CT001-PT-MDB0001",  
            "name": "Programmable Thermostats",  
            "unit": "pieces",  
            "delivery_time": {  
               "amount": 3,  
               "unit": "seconds"  
            },  
            "status": [  
               {  
                  "name": "placed",  
                  "update_timestamp": {  
                     "$date": "2024-04-08T15:13:58.822Z"  
                  }  
               },  
               {  
                  "name": "arrived",  
                  "update_timestamp": {  
                     "$date": "2024-04-08T15:14:03.741Z"  
                  }  
               }  
            ],  
            "amount": 15,  
            "product": {  
               "id": {  
                  "$oid": "65cce1a4ccdfb7402dbb4db4"  
               },  
               "name": "Controls and Thermostats",  
               "image": {  
                  "url": "/images/products/thermostats.png"  
               }  
            }  
         }  
      ],  
      "automatic": true,  
      "transaction_number": 133  
   }  


Building the Solution
---------------------

Building this solution involves five major steps, encompassing MongoDB
Atlas setup, your app configuration, and optional personalization steps.
In the `GitHub repository
<https://github.com/mongodb-industry-solutions/inventory-management>`__
you will find detailed instructions on how to build this solution.

.. procedure::
   :style: normal

   .. step:: Replicate the Demo Database

      Create a MongoDB Atlas cluster and replicate the collections,
      views, and indexes from the demo database.
      
   .. step:: Add the Auto-Replenishment Trigger

      Create a database trigger that automatically issues a
      replenishment order when stock levels fall below a defined
      threshold. For demo purposes, set up a second trigger to simulate
      an order’s progress from placement to fulfillment.

   .. step:: Enable full-text search and filter facets

      Configure search indexes for `full-text search
      <https://www.mongodb.com/resources/basics/full-text-search>`__ and
      filter facets in the products and transactions collections.

   .. step::  Set up real-time analytics with Atlas Charts

      Enhance your application's visualization and analytics
      capabilities with `Atlas Charts
      <https://www.mongodb.com/products/platform/atlas-charts>`__.
      Unlock real-time analytics and create custom charts based on your
      preferences.

   .. step:: Configure your app frontend

      Clone the GitHub repository to your local machine, update the
      environment variables with your own values, install the
      dependencies, and run the app locally on http://localhost:3000.

Key Learnings
-------------

Throughout this solution, we’ve covered multiple MongoDB topics. Here’s
a quick recap of the key learnings: 

- **Real-time alerts:** Implement real-time low-stock alerts in your
  frontend using Change Streams. 

- **Workflow automation:** Leverage database triggers to
  automate stock replenishment workflows.

- **Real-time analytics:** Stay on top of your data, analyze trends, and
  make informed decisions in a timely manner with Atlas Charts.

- **Single view of inventory:** Take advantage of the
  flexibility of the document model to create a comprehensive single view
  of inventory. 

Remember that this is just the beginning. Feel free to explore, tweak,
and enhance your inventory management system to fit your own needs.

Technologies and Products Used
------------------------------

MongoDB Developer Data Platform
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- `MongoDB Atlas <https://www.mongodb.com/atlas>`__
- `Change Streams <https://www.mongodb.com/docs/manual/changeStreams/>`__
- `MongoDB Atlas Triggers <https://www.mongodb.com/docs/atlas/atlas-ui/triggers/>`__
- `MongoDB Node.js driver <https://www.mongodb.com/docs/drivers/node/current/>`__

Author
------

- Angie Guemes, MongoDB
- Florencia Arin, MongoDB 